generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id        String   @id @default(cuid())
  name      String
  username  String   @unique
  password  String
  role      UserRole @default(WAITER)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  orders          Order[] // Pedidos feitos pelo garçom
  cashierSessions Cashier[] // Turnos de caixa abertos por este usuário

  @@index([role])
}

enum UserRole {
  ADMIN
  CASHIER
  WAITER
}

// ==========================================
// PRODUTOS E ESTOQUE (Simplificado)
// ==========================================

model Product {
  id            String          @id @default(cuid())
  name          String          @unique
  description   String?
  sellingPrice  Decimal         @db.Decimal(10, 2)
  unitOfMeasure String // "L", "UN", "KG"
  category      ProductCategory // Adicionado para filtros (Chopp, Food, etc)

  // Controle de Estoque Simplificado (Movido de tabela separada)
  stock         Float     @default(0)
  minStockLevel Float     @default(0)
  batch         String? // Lote atual/principal
  expiryDate    DateTime? // Validade do lote atual

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  orderItems OrderItem[]
  purchases  Purchase[] // Histórico de entradas

  imageUrl String? 

  @@index([category])
}

enum ProductCategory {
  CHOPP
  FOOD
  DRINK
  OTHER
}

// ==========================================
// FORNECEDORES E COMPRAS
// ==========================================

model Supplier {
  id        String   @id @default(cuid())
  name      String   @unique
  cnpj      String?
  contact   String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  purchases Purchase[]
}

model Purchase {
  id           String   @id @default(cuid())
  quantity     Float
  costPrice    Decimal  @db.Decimal(10, 2)
  purchaseDate DateTime @default(now())
  batch        String? // Opcional: Registrar qual lote entrou nesta compra

  productId  String
  product    Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  supplierId String
  supplier   Supplier @relation(fields: [supplierId], references: [id], onDelete: Cascade)

  @@index([productId])
  @@index([supplierId])
}

// ==========================================
// PEDIDOS E VENDAS
// ==========================================

model Order {
  id      String      @id @default(cuid())
  tableId Int // Mudado para Int conforme solicitado
  status  OrderStatus @default(OPEN)

  // Valores Financeiros do Pedido
  subtotal Decimal @default(0) @db.Decimal(10, 2)
  discount Decimal @default(0) @db.Decimal(10, 2)
  tip      Decimal @default(0) @db.Decimal(10, 2)
  total    Decimal @default(0) @db.Decimal(10, 2) // subtotal - discount + tip

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  closedAt  DateTime?

  waiterId String
  waiter   User        @relation(fields: [waiterId], references: [id], onDelete: Cascade)
  items    OrderItem[]
  payments Payment[]

  @@index([waiterId])
  @@index([status])
  @@index([createdAt])
}

enum OrderStatus {
  OPEN
  CLOSED
  PAID
  CANCELLED // Sugestão: bom ter status de cancelado
}

model OrderItem {
  id         String   @id @default(cuid())
  quantity   Float
  unitPrice  Decimal  @db.Decimal(10, 2)
  isCourtesy Boolean  @default(false)
  createdAt  DateTime @default(now())

  orderId   String
  order     Order   @relation(fields: [orderId], references: [id], onDelete: Cascade)
  productId String
  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@index([orderId])
  @@index([productId])
}

// ==========================================
// FINANCEIRO E CAIXA
// ==========================================

model Payment {
  id            String        @id @default(cuid())
  amount        Decimal       @db.Decimal(10, 2)
  paymentMethod PaymentMethod
  createdAt     DateTime      @default(now())

  orderId String
  order   Order  @relation(fields: [orderId], references: [id], onDelete: Cascade)

  // Conexão crucial: Pagamento pertence a um turno de caixa específico
  cashierId String
  cashier   Cashier @relation(fields: [cashierId], references: [id], onDelete: Cascade)

  @@index([orderId])
  @@index([cashierId])
}

enum PaymentMethod {
  CASH
  DEBIT
  CREDIT
  PIX
}

model Cashier {
  id          String    @id @default(cuid())
  openingDate DateTime  @default(now())
  closingDate DateTime?

  initialAmount Decimal  @db.Decimal(10, 2) // Fundo de troco
  finalAmount   Decimal? @db.Decimal(10, 2) // Quanto tem na gaveta ao fechar

  // Quem abriu este caixa?
  openedById String
  openedBy   User   @relation(fields: [openedById], references: [id], onDelete: Cascade)

  // Relação inversa para saber todo o dinheiro que entrou neste turno
  payments Payment[]

  detailsJson Json? // Para logs de conferência ou erros de fechamento
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([openedById])
  @@index([openingDate])
}